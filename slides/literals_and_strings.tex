\section{Literale}
\begin{frame}{Literale}
    \begin{block}{Was ist ein Literal?}
    Literale sind Bestandteil der Syntax der meisten Sprachen, die dazu dienen, Daten direkt in den Quellcode zu schreiben.
    \end{block}
    \pause
    \begin{block}{Beispiele für Literale in C++}
    \begin{table}
    \center
    \begin{tabular}{ll}
        \toprule
        Typ & Beispiel \\
        \midrule
        char & 'A' \\
        const char[] (char-Array, Null-terminiert!) & "Hello World!" \\
        int & 42 \\
        double & 1.6e-19 \\
        \bottomrule
    \end{tabular}
    \caption{Literale in C++}
    \end{table}
    \end{block}
\end{frame}

\begin{frame}{Escape-Sequenzen}
    \begin{block}{Escape-Sequenzen in String-Literalen in C++}
    \begin{table}
    \center
    \begin{tabular}{ll}
        \toprule
        Sequenz & Wirkung \\
        \midrule
        \textbackslash n & Neue Zeile \\
        \textbackslash r & Tabulator \\
        \textbackslash\textbackslash & Backslash (\textbackslash) \\
        \textbackslash" & Doppeltes Anführungszeichen (") \\
        \textbackslash' & Einfaches Anführungszeichen (') \\
        \bottomrule
    \end{tabular}
    \end{table}
    \end{block}
\end{frame}

\begin{frame}{Weniger häufig genutzte Literale}
    \begin{block}{Weitere Beispiele für Literale}
        \begin{table}
        \center
        \begin{tabular}{ll}
            \toprule
            Typ & Beispiel \\
            \midrule
            Oktalzahl (int) & 042 \\
            Hexadezimalzahl (int) & 0x732 \\
            \midrule
            \pause
            unsigned int & 42u \\
            unsigned int, Oktal & 042u \\
            \midrule
            \pause
            C++11: Benutzerdefiniert & 42.7\_meter \\
            \bottomrule
        \end{tabular}
        \caption{Weitere Literale in C++}
        \end{table}
    \end{block}
\end{frame}

\section{Strings}

\begin{frame}{Probleme mit C-Strings}
    \begin{block}{Probleme mit C-Strings}
    \begin{itemize}
    \item Schwierige Handhabung, z.\,B. wegen Null-Terminierung
    \item Keine einfache Möglichkeit, mehr als die Ascii-Zeichen zu benutzen (zum Beispiel Unicode)
    \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{String-Klassen}
    \begin{block}{std::string}
    \texttt{std::string} ist die String-Klasse der Standardbibliothek. Praktische Methoden:
    \begin{itemize}
    \item \texttt{size()}
    \item \texttt{append(str)}, \texttt{insert(position, str)}
    \item \texttt{operator==(str)}
    \end{itemize}
    Anders als mit \texttt{char}-Arrays kann man also zum Beispiel Strings direkt vergleichen:
    \texttt{if ( str1 == str2 ) { ... }}
    \end{block}
\end{frame}

\begin{frame}{String-Klassen}
    \begin{block}{QString}
    \texttt{QString} ist die String-Klasse der Qt-Bibliothek\footnote{\url{http://qt-project.org/}}. Im Gegensatz zu \texttt{std::string} bietet \texttt{QString} echte Unicode-Unterstützung, und viele weitere nützliche Methoden, zum Beispiel:
    \begin{itemize}
    \item \texttt{replace(QRegExp, QString)} -- suchen und Ersetzen mit regulären Ausdrücken
    \item \texttt{repeated(int)} -- wiederholt den String einige Male
    \item \texttt{trimmed()} -- entfernt Leerzeichen vorne und hinten im String
    \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{String-Klassen}
	enemy slide injection :P
	
    \begin{block}{STL und Unicode}
    Die Unicode-Unterstützung der STL steckt in den Algorithmen, nicht in \texttt{std::string}:
    \begin{itemize}
    \item \texttt{std::regex\_replace(string, regex, string)} -- suchen und Ersetzen mit regulären Ausdrücken
    \item \texttt{string+=string} -- wiederholt den String einmal (einige Male == einmal 5-zeilige Funktion)
    \item \texttt{stream>>skipws>>string} -- entfernt Leerzeichen vorne und hinten im String
	\tiny
	\item \texttt{string.substr( find\_if(string.begin(), string.end(), bind( isprint, \_1, loc), reverse\_iterator(find\_if(string.rbegin(), string.rend(), bind( isprint, \_1, loc) )} -- entfernt Leerzeichen vorne und hinten im String
    \end{itemize}
    \end{block}
\end{frame}
